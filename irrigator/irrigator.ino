#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// macros from DateTime.h
/* Useful Constants */
#define SECS_PER_MIN (60UL)
#define SECS_PER_HOUR (3600UL)
#define SECS_PER_DAY (SECS_PER_HOUR * 24L)

/* Useful Macros for getting elapsed time */
#define numberOfSeconds(_time_) (_time_ % SECS_PER_MIN)
#define numberOfMinutes(_time_) ((_time_ / SECS_PER_MIN) % SECS_PER_MIN)
#define numberOfHours(_time_) ((_time_ % SECS_PER_DAY) / SECS_PER_HOUR)
#define elapsedDays(_time_) (_time_ / SECS_PER_DAY)

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

#define BUTTON_UP 13
#define BUTTON_DOWN 12

#define SENSOR 2
#define SENSOR_LOW 625
#define SENSOR_HIGH 320
#define OFFSET 0

#define VALVE 2
#define TIMEOUT 30000
#define TIMEOUT_DELAY 25000
unsigned long generalTimeCounter;
bool isValveOn = false;

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET -1 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

int threshold = 60;
int lastButtonUpState = 0;
int lastButtonDownState = 0;
int sensor = 40;

int yPos = 40;
int barHeight = 12;
int thresholdPixelXPos;


static const unsigned char PROGMEM logo_ico[] = { // 116x42px
    0x40, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 
	0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x00, 0x00, 0x04, 0x04, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xe0, 0x1f, 0xf0, 0x0e, 0x0e, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x7f, 0xfc, 0x04, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0xff, 0xfe, 0x20, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x1c, 0xff, 0xfe, 0x70, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0xff, 0xfe, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0xff, 0xfe, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xe0, 0xe0, 0x0f, 0xe0, 0x0e, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x40, 0x0f, 0xe0, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x00, 0x0f, 0xe0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x0e, 0x00, 0x0f, 0xe0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
	0x00, 0x1f, 0xf0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x1f, 0xf0, 0x00, 0x04, 0x00, 0xe0, 0x7d, 0xff, 0xcf, 0x80, 0x7c, 0x1f, 0x00, 0xe0, 0x00, 0x1f, 
	0xf0, 0x00, 0x0e, 0x00, 0x70, 0x38, 0x70, 0xc3, 0x80, 0xf0, 0x71, 0xc0, 0x40, 0x00, 0x1f, 0xf0, 
	0x00, 0x04, 0x00, 0x38, 0x10, 0x70, 0x43, 0xc0, 0xf0, 0xe0, 0xe0, 0x00, 0x00, 0x1f, 0xf0, 0x00, 
	0x00, 0x00, 0x3c, 0x10, 0x70, 0x02, 0xc1, 0x70, 0xc0, 0x60, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 
	0x00, 0x2e, 0x10, 0x72, 0x02, 0xe1, 0x71, 0xc0, 0x70, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 
	0x27, 0x10, 0x72, 0x02, 0x61, 0x71, 0xc0, 0x70, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x23, 
	0x90, 0x7e, 0x02, 0x3a, 0x71, 0xc0, 0x70, 0x00, 0x00, 0x1f, 0xf2, 0x00, 0x00, 0x00, 0x21, 0xd0, 
	0x72, 0x02, 0x3a, 0x71, 0xc0, 0x70, 0x00, 0x00, 0x1f, 0xf3, 0x00, 0x00, 0x00, 0x20, 0xf0, 0x72, 
	0x02, 0x1c, 0x70, 0xc0, 0x60, 0x00, 0x10, 0x1f, 0xf3, 0x80, 0x00, 0x00, 0x20, 0x70, 0x70, 0x22, 
	0x1c, 0x70, 0xe0, 0xc0, 0x00, 0x10, 0x1f, 0xf1, 0x80, 0x40, 0x00, 0x70, 0x30, 0x70, 0x62, 0x0c, 
	0x70, 0x71, 0x80, 0x00, 0x30, 0x1f, 0xf1, 0xc0, 0xc0, 0x00, 0xf8, 0x11, 0xff, 0xef, 0x89, 0xfc, 
	0x1f, 0x00, 0x00, 0x70, 0x1f, 0xf1, 0xe1, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x70, 0x1f, 0xf1, 0xe3, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x18, 0x66, 0x1f, 0xf1, 0xe7, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 
	0xe6, 0x1f, 0xf1, 0xf7, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xec, 
	0x1f, 0xf0, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xfc, 0x1f, 
	0xf0, 0xff, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xfd, 0x7f, 0xfc, 
	0xfe, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0xfb, 0x7f, 0xfc, 0xfe, 
	0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0xff, 0x7f, 0xfc, 0xfe, 0x70, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0xfe, 0x7f, 0xfc, 0xfe, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x7f, 0xfc, 0xfe, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x7f, 0xfc, 0xfe, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00};


static const unsigned char PROGMEM water_ico[] = { // 9x16px
    0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x1c, 0x00, 0x1c, 0x00, 0x2e, 0x00, 0x6f, 0x00, 0x4f, 0x00,
    0x8f, 0x80, 0x9f, 0x80, 0x9f, 0x80, 0x9f, 0x80, 0x7f, 0x80, 0x7f, 0x00, 0x1e, 0x00, 0x00, 0x00};

static const unsigned char PROGMEM wait_ico[] = { // 9x16px
    0xff, 0x80, 0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0x41, 0x00, 0x63, 0x00, 0x22, 0x00, 0x14, 0x00,
    0x14, 0x00, 0x22, 0x00, 0x63, 0x00, 0x41, 0x00, 0x9c, 0x80, 0xbe, 0x80, 0xff, 0x80, 0xff, 0x80};

static const unsigned char PROGMEM standby_ico[] = { // 9x16px
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x80, 0xfd, 0x00,
    0x0a, 0x00, 0x17, 0x80, 0x20, 0x00, 0x40, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

static const unsigned char PROGMEM limit_ico[] = { // 9x16px
    0x00, 0x00, 0x3e, 0x00, 0x1c, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00,
    0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x1c, 0x00, 0x3e, 0x00};

void setup()
{
  Serial.begin(9600);

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C))
  { // Address 0x3D for 128x64
    Serial.println(F("SSD1306 allocation failed"));
    for (;;)
      ; // Don't proceed, loop forever
  }

  display.clearDisplay();

  display.drawBitmap(6, 19, logo_ico, 116, 42, WHITE);
  display.display();
  delay(2000);

  // Clear the buffer
  display.clearDisplay();
  display.setTextColor(WHITE, BLACK);

  display.drawBitmap(SCREEN_WIDTH - 30, 0, limit_ico, 9, 16, WHITE);

  standby();

  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(BUTTON_UP, INPUT);
  pinMode(BUTTON_DOWN, INPUT);

  waterOFF();
  generalTimeCounter = millis();
}

void loop()
{
  updateProcesses();

  if (sensor < threshold)
  {
    irrigate();
    generalTimeCounter = millis();
  }
  else
  {
    standby();
  }
}

void updateProcesses()
{
  display.fillTriangle(thresholdPixelXPos - 3, yPos, thresholdPixelXPos + 3, yPos, thresholdPixelXPos, yPos + 3, BLACK);
  display.fillTriangle(thresholdPixelXPos - 3, yPos + 19, thresholdPixelXPos + 3, yPos + 19, thresholdPixelXPos, yPos + 16, BLACK);

  readButtons();
  updateThreshold();
  readSensor();
  updateProgressBar();
  display.display();
}

void standby()
{
  updateStatus("Stand by");
  display.fillRect(0, 0, 9, 16, BLACK);
  display.drawBitmap(0, 0, standby_ico, 9, 16, WHITE);
  unsigned long delta = millis() - generalTimeCounter;
  millsToDays(delta);
  delay(200);
}

void irrigate()
{
  updateStatus("Irrigating");
  display.fillRect(0, 0, 9, 16, BLACK);
  display.drawBitmap(0, 0, water_ico, 9, 16, WHITE);
  waterON();
  display.display();

  unsigned long startTime = millis();
  unsigned long deltaTime = millis() - startTime;

  int counter = 0;
  bool isIconHidden = false;

  while (deltaTime < TIMEOUT && sensor < threshold)
  {
    deltaTime = millis() - startTime;
    millsToTime(TIMEOUT - deltaTime);
    updateProcesses();
    delay(200);
    counter++;
    if (counter == 3)
    {
      isIconHidden = !isIconHidden;
      if (isIconHidden)
      {
        display.drawBitmap(0, 0, water_ico, 9, 16, WHITE);
      }
      else
      {
        display.fillRect(0, 0, 9, 16, BLACK);
      }
      display.display();
      counter = 0;
    }
  }

  waterOFF();
  if (sensor < threshold)
  {
    timeOUT();
  }
}

void timeOUT()
{
  updateStatus("Delaying");
  display.fillRect(0, 0, 9, 16, BLACK);
  display.drawBitmap(0, 0, wait_ico, 9, 16, WHITE);
  unsigned long startTime = millis();
  unsigned long deltaTime = millis() - startTime;
  display.display();

  while (deltaTime < TIMEOUT_DELAY)
  {
    deltaTime = millis() - startTime;
    millsToTime(TIMEOUT_DELAY - deltaTime);
    updateProcesses();
    delay(200);
  }
}

void updateStatus(String status)
{
  display.fillRect(14, 0, 14 + 10 * 6, 8, BLACK);
  display.setTextSize(1);
  display.setCursor(14, 0);
  display.println(status);
}

void updateTime(String time)
{
  display.setTextSize(1);
  display.setCursor(14, 8);
  display.fillRect(14, 8, 14 + 10 * 6, 16, BLACK);
  display.println(time);
}

void updateThreshold()
{
  display.setTextSize(1);
  display.setCursor(SCREEN_WIDTH - 19, 4);
  if (threshold < 10)
    display.print("0");
  display.print(threshold);
  display.println("%");
}

void updateProgressBar()
{
  display.drawRoundRect(0, yPos + 4, SCREEN_WIDTH, barHeight, barHeight / 2, WHITE);
  display.fillRoundRect(1, yPos + 5, SCREEN_WIDTH - 2, barHeight - 2, (barHeight - 2) / 2, BLACK);
  display.fillRoundRect(2, yPos + 6, map(sensor, 0, 99, 0, SCREEN_WIDTH - 4), barHeight - 4, (barHeight - 4) / 2, WHITE);

  thresholdPixelXPos = map(threshold, 0, 99, 2, SCREEN_WIDTH - 2);
  display.fillTriangle(thresholdPixelXPos - 3, yPos, thresholdPixelXPos + 3, yPos, thresholdPixelXPos, yPos + 3, WHITE);
  display.fillTriangle(thresholdPixelXPos - 3, yPos + 19, thresholdPixelXPos + 3, yPos + 19, thresholdPixelXPos, yPos + 16, WHITE);

  display.drawPixel(thresholdPixelXPos, yPos + 6, WHITE);
  display.drawPixel(thresholdPixelXPos, yPos + 7, WHITE);
  display.drawPixel(thresholdPixelXPos, yPos + 9, WHITE);
  display.drawPixel(thresholdPixelXPos, yPos + 10, WHITE);
  display.drawPixel(thresholdPixelXPos, yPos + 12, WHITE);
  display.drawPixel(thresholdPixelXPos, yPos + 13, WHITE);
}

void readButtons()
{
  int buttonUpState = digitalRead(BUTTON_UP);
  int buttonDownState = digitalRead(BUTTON_DOWN);

  if (buttonUpState)
  {
    if (threshold != 99)
      threshold++;
  }

  if (buttonDownState)
  {
    if (threshold != 0)
      threshold--;
  }
}

void waterON()
{
  isValveOn = true;
  digitalWrite(VALVE, isValveOn);
  digitalWrite(LED_BUILTIN, isValveOn);
}

void waterOFF()
{
  isValveOn = false;
  digitalWrite(VALVE, isValveOn);
  digitalWrite(LED_BUILTIN, isValveOn);
}

void millsToTime(unsigned long mills)
{
  mills = mills / 1000;
  int minutes = numberOfMinutes(mills);
  int seconds = numberOfSeconds(mills);

  char buf[11];
  sprintf(buf, "%02d:%02d", minutes, seconds);
  updateTime(buf);
}

void millsToDays(unsigned long mills)
{
  mills = mills / 1000;
  int days = elapsedDays(mills);
  int hours = numberOfHours(mills);
  int minutes = numberOfMinutes(mills);
  int seconds = numberOfSeconds(mills);

  char buf[11];
  sprintf(buf, "%02d:%02d:%02d:%02d", days, hours, minutes, seconds);
  updateTime(buf);
}

void readSensor()
{
  int rawSensorData = analogRead(SENSOR);
  sensor = map(rawSensorData, SENSOR_HIGH + OFFSET, SENSOR_LOW + OFFSET, 100, 0);

  display.setTextSize(2);
  display.setCursor(55, 20);
  display.fillRect(0, 20, 128, 36, BLACK);
  //char sensorValue[50];
  //sprintf(sensorValue, "%02d%% (%02d)", moitureInPercentage, rawSensorData);
  //display.println(sensorValue);
  display.print(sensor);
  display.print(F("%"));
}